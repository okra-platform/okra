// This file is auto-generated by OKRA. Do not edit.

// Javy global types
declare const Javy: {
  IO: {
    readSync(fd: number, buffer: Uint8Array): number;
    writeSync(fd: number, buffer: Uint8Array): number;
  };
};

/**
 * Reads JSON input from stdin
 */
export function readInput(): any {
  const chunkSize = 1024;
  const chunks: Uint8Array[] = [];
  let totalLength = 0;

  while (true) {
    const chunk = new Uint8Array(chunkSize);
    const bytesRead = Javy.IO.readSync(0, chunk);
    
    if (bytesRead <= 0) break;
    
    chunks.push(chunk.slice(0, bytesRead));
    totalLength += bytesRead;
    
    if (bytesRead < chunkSize) break;
  }

  // Concatenate all chunks
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  const decoder = new TextDecoder();
  const text = decoder.decode(result);
  
  try {
    return JSON.parse(text);
  } catch (error) {
    throw new Error(`Failed to parse input as JSON: ${text}`);
  }
}

/**
 * Writes JSON output to stdout
 */
export function writeOutput(output: any): void {
  const encoder = new TextEncoder();
  const outputText = JSON.stringify(output);
  const outputBytes = encoder.encode(outputText);
  
  let offset = 0;
  while (offset < outputBytes.length) {
    const written = Javy.IO.writeSync(1, outputBytes.subarray(offset));
    if (written <= 0) {
      throw new Error('Failed to write output');
    }
    offset += written;
  }
}

/**
 * Logs a message to stderr for debugging
 */
export function log(message: string): void {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(message + '\n');
  Javy.IO.writeSync(2, bytes);
}