//go:build wasi || wasip1
// +build wasi wasip1

// Code generated by OKRA. DO NOT EDIT.
package main

// #include <stdlib.h>
import "C"
import (
	"encoding/json"
	"unsafe"

	userservice "{{.UserPackageImport}}"
	"{{.ModulePath}}/types"
)

// service holds the user's service implementation
var service types.{{.ServiceInterfaceName}}

// main is required but not called in reactor mode
func main() {
	// Reactor module - main should not be called
}

// _initialize is called once when the module is instantiated
//
//export _initialize
func _initialize() {
	// Call the user's constructor to get the service implementation
	service = userservice.{{.ConstructorName}}()
}

// handle_request is the main entry point for service method calls
//
//export handle_request
func handle_request(methodPtr, methodLen, inputPtr, inputLen uint32) uint64 {
	method := ptrToString(methodPtr, methodLen)
	input := ptrToBytes(inputPtr, inputLen)

	var output []byte
	var err error

	// Dispatch to the appropriate service method
	switch method {
{{range .Methods}}	case "{{.LowerName}}":
		var req types.{{.InputType}}
		err = json.Unmarshal(input, &req)
		if err != nil {
			return encodeError(err)
		}
		res, err := service.{{.Name}}(&req)
		if err != nil {
			return encodeError(err)
		}
		output, err = json.Marshal(res)
		if err != nil {
			return encodeError(err)
		}
{{end}}	default:
		return encodeError(&errUnknownMethod{method: method})
	}

	// Allocate memory for output
	ptr := allocate(uint32(len(output)))
	copy(ptrToBytes(ptr, uint32(len(output))), output)

	// Return pointer and length as uint64 (ptr << 32 | len)
	return uint64(ptr)<<32 | uint64(len(output))
}

// allocate allocates memory in the WASM module's linear memory
//
//export allocate
func allocate(size uint32) uint32 {
	ptr := C.malloc(C.size_t(size))
	return uint32(uintptr(ptr))
}

// deallocate frees memory in the WASM module's linear memory
//
//export deallocate
func deallocate(ptr uint32) {
	C.free(unsafe.Pointer(uintptr(ptr)))
}

// Memory management helpers

func ptrToString(ptr, len uint32) string {
	return string(ptrToBytes(ptr, len))
}

func ptrToBytes(ptr, len uint32) []byte {
	if len == 0 {
		return nil
	}
	return unsafe.Slice((*byte)(unsafe.Pointer(uintptr(ptr))), len)
}

// Error handling

type errUnknownMethod struct {
	method string
}

func (e *errUnknownMethod) Error() string {
	return "unknown method: " + e.method
}

type errorResponse struct {
	Error string `json:"error"`
}

func encodeError(err error) uint64 {
	resp := errorResponse{Error: err.Error()}
	output, _ := json.Marshal(resp)
	
	ptr := allocate(uint32(len(output)))
	copy(ptrToBytes(ptr, uint32(len(output))), output)
	
	// Set high bit to indicate error
	return uint64(ptr)<<32 | uint64(len(output)) | (1 << 63)
}